use tch::{nn, nn::Module, nn::OptimizerConfig, Device, Tensor};

#[derive(Debug)]
struct SimpleNN {
    layer1: nn::Linear,
    layer2: nn::Linear,
    layer3: nn::Linear,
    layer4: nn::Linear,
    layer5: nn::Linear,
    layer6: nn::Linear,
    output_layer: nn::Linear,
}

impl SimpleNN {
    fn new(vs: &nn::Path, input_size: i64, num_classes: i64) -> SimpleNN {
        let layer1 = nn::linear(vs / "layer1", input_size, 1024, Default::default());
        let layer2 = nn::linear(vs / "layer2", 1024, 512, Default::default());
        let layer3 = nn::linear(vs / "layer3", 512, 256, Default::default());
        let layer4 = nn::linear(vs / "layer4", 256, 128, Default::default());
        let layer5 = nn::linear(vs / "layer5", 128, 64, Default::default());
        let layer6 = nn::linear(vs / "layer6", 64, 32, Default::default());
        let output_layer = nn::linear(vs / "output_layer", 32, num_classes, Default::default());
        SimpleNN {
            layer1,
            layer2,
            layer3,
            layer4,
            layer5,
            layer6,
            output_layer,
        }
    }
}

impl nn::Module for SimpleNN {
    fn forward(&self, xs: &Tensor) -> Tensor {
        xs.view([-1, 2368])
            .apply(&self.layer1).relu()
            .apply(&self.layer2).relu()
            .apply(&self.layer3).relu()
            .apply(&self.layer4).relu()
            .apply(&self.layer5).relu()
            .apply(&self.layer6).relu()
            .apply(&self.output_layer)
            .view([-1, 1])
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Set the device (use CUDA if available)
    let device = if tch::Cuda::is_available() {
        Device::Cuda(0)
    } else {
        Device::Cpu
    };

    // Load the model
    let vs = nn::VarStore::new(device);
    let model = SimpleNN::new(&vs.root(), 2368, 1);
    let model_path = "model.pth";
    vs.load(model_path)?;

    // Example input tensor (replace with actual data)
    let input = Tensor::randn(&[1, 2368], (tch::Kind::Float, device));  // Adjust dimensions based on your model's input size

    // Evaluate the model
    let output = model.forward(&input);
    println!("Model output: {:?}", output);

    Ok(())
}
